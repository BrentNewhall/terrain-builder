<!DOCTYPE html>
<html>
<head>
    <title>Mini Builder</title>
    <link rel="stylesheet" href="style.css" />
</head>

<body>

<div id="controls">
    <div>Rows:</div>
    <div><button onclick="updateRows(-1)">-</button> <span id="rows"></span> <button onclick="updateRows(1)">+</button></div>
    <div>Columns:</div>
    <div><button onclick="updateCols(-1)">-</button> <span id="cols"></span> <button onclick="updateCols(1)">+</button></div>
    <br />
    <div><button onclick="saveSTL()">Download</button></div>
</div>
<div id="speed"></div>

<script src="three.js"></script>
<script src="STLExporter.js"></script>
<script src="FileSaver.js"></script>
<script>

var tileSize = 25;
var mesh = null;
var rows = 2;
var cols = 2;
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

// Base
var baseGeometry = new THREE.BoxGeometry( tileSize, 0.1, tileSize );
baseGeometry.computeFaceNormals();
baseGeometry.computeVertexNormals();
let material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
var base = new THREE.Mesh( baseGeometry, material );
scene.add( base );
var tiles = [];

// Light
var light = new THREE.DirectionalLight( 0xffffff, 1 );
light.position.z = 2;
scene.add( light );

// Position camera
camera.position.z = 70;
camera.position.y = -70;

var clock = new THREE.Clock();
var matrix = new THREE.Matrix4();

function animate() {
    requestAnimationFrame( animate );
    //base.rotation.y += 0.01;
    const elapsedTime = clock.getElapsedTime();
    //matrix.makeRotationZ( clock.getDelta() * 2 * Math.PI * 10 );
    //camera.position.applyMatrix4( matrix );
    camera.position.x = 50 * Math.cos( elapsedTime * 0.5 );
    camera.position.y = 50 * Math.sin( elapsedTime * 0.5 );
    camera.lookAt( base.position );
    renderer.render( scene, camera );
}

function updateScreenControls() {
    document.getElementById("rows").innerHTML = rows;
    document.getElementById("cols").innerHTML = cols;
    let geometry = new THREE.BoxGeometry( rows * tileSize, cols * tileSize, 0.1 );
    base.geometry.dispose();
    base.geometry = geometry;
    // Remove all existing tiles
    for( let tile of tiles ) {
        scene.remove( tile );
    }
    // Generate tiles
    const halfTileSize = tileSize * 0.5;
    const rowOffset = halfTileSize * rows - halfTileSize;
    const colOffset = halfTileSize * cols - halfTileSize;
    const tileMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff } );
    for( let row = 0; row < rows; row++ ) {
        for( let col = 0; col < cols; col++ ) {
            const tileGeometry = new THREE.BoxGeometry( tileSize * 0.9, tileSize * 0.9, tileSize * 0.1 );
            tileGeometry.computeFaceNormals();
            tileGeometry.computeVertexNormals();
            let tile = new THREE.Mesh( tileGeometry, tileMaterial );
            tile.position.z = tileSize * 0.05;
            tile.position.x = row * tileSize - rowOffset;
            tile.position.y = col * tileSize - colOffset;
            scene.add( tile );
            tiles.push( tile );
        }
    }
}

function updateRows( amount ) {
    if( rows + amount >= 1  &&  rows + amount <= 5 ) {
        rows += amount;
        updateScreenControls();
    }
}

function updateCols( amount ) {
    if( cols + amount >= 1  &&  cols + amount <= 5 ) {
        cols += amount;
        updateScreenControls();
    }
}

function saveSTL() {
    var exporter = new THREE.STLExporter();
    var stlString = exporter.parse( scene );
    var blob = new Blob([stlString], {type: 'text/plain'});
    saveAs( blob, 'tile.stl' );
}

updateScreenControls();
animate();
</script>

</body>
</html>

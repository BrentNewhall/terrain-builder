<!DOCTYPE html>
<html>
<head>
    <title>Terrain Builder</title>
    <meta name="description" content="Create tabletop terrain tiles and download an STL file for 3D printing." />
    <meta charset="utf-8" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <!-- Compiled and minified Materialize CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <!-- Compiled and minified Materalize JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <link rel="stylesheet" href="style.css" />
</head>

<body>

<div id="controls">
    <h1>Terrain Builder</h1>
    <div>Rows:</div>
    <input type="range" id="rows" min="1" max="8" value="2" onchange="setRows()" />
    <br />
    <div>Columns:</div>
    <input type="range" id="cols" min="1" max="8" value="2" onchange="setCols()" />
    <br />
    <div>Walls:</div>
    <button class="wallBtnHorizontal" id="northWall" onclick="toggleWall('northWall')">&nbsp;</button><br />
    <button class="wallBtnVertical" id="eastWall" onclick="toggleWall('eastWall')">&nbsp;</button>
    <button class="wallBtnVertical" id="westWall" onclick="toggleWall('westWall')">&nbsp;</button><br />
    <button class="wallBtnHorizontal" id="southWall" onclick="toggleWall('southWall')">&nbsp;</button><br />
    <select id="wallHeight" onchange="changeWallHeight()">
        <option value="low">Low walls</option>
        <option value="high">High walls</option>
    </select>
    <br />
    <select id="feature" onchange="changeFeature()">
        <option value="none">Add feature...</option>
        <option value="fountain">Fountain</option>
    </select>
    <!-- Loading spinner -->
    <div id="spinner">
        <div class="preloader-wrapper big active">
            <div class="spinner-layer spinner-blue-only">
                <div class="circle-clipper left">
                    <div class="circle"></div>
                </div>
                <div class="gap-patch">
                    <div class="circle"></div>
                </div>
                <div class="circle-clipper right">
                    <div class="circle"></div>
                </div>
            </div>
        </div>
    </div>
    <br />
    <div style="display: flex; justify-content: space-around">
        <button class="btn" id="downloadBtn" onclick="saveSTL()">Download</button>
        <button class="btn orange" onclick="reset()">Reset</button>
        <a class="waves-effect waves-light btn grey modal-trigger" href="#helpModal">Help</a><br />
    </div>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- img width="300" height="250" alt="Temp" src="http://lorempixel.com/300/250" / -->
</div>

<div id="speed"></div>

<script src="three.js"></script>
<script src="STLExporter.js"></script>
<script src="FileSaver.js"></script>
<script src="loaders/STLLoader.js"></script>

<script>
var tileSize = 30.5;
var mesh = null;
var rows = 2;
var cols = 2;
var mouseHovering = false;
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth - 320, window.innerHeight );
document.body.appendChild( renderer.domElement );
renderer.domElement.id = "mainCanvas";
document.getElementById("mainCanvas").addEventListener("mouseover", (e) => {
    mouseHovering = true;
})
document.getElementById("controls").addEventListener("mouseover", (e) => {
    mouseHovering = false;
})

// Base
var origin = new THREE.Vector3( 0, 0, 0 );
/* var baseGeometry = new THREE.BoxGeometry( tileSize, tileSize * 0.1, tileSize );
baseGeometry.computeFaceNormals();
baseGeometry.computeVertexNormals();
let material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
var base = new THREE.Mesh( baseGeometry, material );
scene.add( base ); */
var bases = [];
var tiles = [];

document.getElementById("mainCanvas").addEventListener('click', function(event) {
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    mouse.x = ( event.clientX / document.getElementById("mainCanvas").clientWidth ) * 2 - 1;
    mouse.y = 0 - ( event.clientY / document.getElementById("mainCanvas").clientHeight ) * 2 + 1;
    raycaster.setFromCamera( mouse, camera );
    let intersects = raycaster.intersectObjects( tiles, true );
    if (intersects.length > 0) {
        let selectedObject = intersects[0];
        scene.remove( selectedObject.object );
 	}
    intersects = raycaster.intersectObjects( bases, true );
    if (intersects.length > 0) {
        let selectedObject = intersects[0];
        scene.remove( selectedObject.object );
 	}
}, false)

// Light
var light = new THREE.DirectionalLight( 0xffffff, 1 );
light.position.z = 2;
scene.add( light );

// Position camera
camera.position.z = 70;
camera.position.y = -70;

var clock = new THREE.Clock();
var matrix = new THREE.Matrix4();

// Terrain feature
var feature = null;
var loader = new THREE.STLLoader();
// Setup select
document.addEventListener('DOMContentLoaded', function() {
    var elems = document.querySelectorAll('select');
    var instances = M.FormSelect.init(elems);
});

// Setup walls
var walls = [];
var wallFlags = [];
for( let i = 0; i < 4; i++ ) {
    wallFlags[i] = false;
}
var northWall = false;
var southWall = false;
var eastWall = false;
var westWall = false;
var wallHeightModBase = 0.375;
var wallHeightMod = 0.375;

var tileMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff } );

function toggleWall( wallId ) {
    /* wallFlags[wallIndex] = wallFlags[wallIndex] ? false : true;
    document.getElementById('wall' + wallIndex).style.backgroundColor = (wallFlags[wallIndex]) ? 'black' : 'white'; */
    if( wallId === 'northWall' ) {
        northWall = northWall ? false : true;
        document.getElementById(wallId).style.backgroundColor = (northWall) ? 'black' : 'white';
    }
    else if( wallId === 'southWall' ) {
        southWall = southWall ? false : true;
        document.getElementById(wallId).style.backgroundColor = (southWall) ? 'black' : 'white';
    }
    else if( wallId === 'eastWall' ) {
        eastWall = eastWall ? false : true;
        document.getElementById(wallId).style.backgroundColor = (eastWall) ? 'black' : 'white';
    }
    else if( wallId === 'westWall' ) {
        westWall = westWall ? false : true;
        document.getElementById(wallId).style.backgroundColor = (westWall) ? 'black' : 'white';
    }
    updateScreenControls();
}

function animate() {
    requestAnimationFrame( animate );
    const elapsedTime = clock.getElapsedTime();
    //matrix.makeRotationZ( clock.getDelta() * 2 * Math.PI * 10 );
    //camera.position.applyMatrix4( matrix );
    if( mouseHovering ) {
        camera.position.x = 0;
        camera.position.y = 0;
    }
    else {
        camera.position.x = 75 * Math.cos( elapsedTime * 0.5 );
        camera.position.y = 75 * Math.sin( elapsedTime * 0.5 );
    }
    camera.lookAt( origin );
    renderer.render( scene, camera );
}

function updateScreenControls() {
    document.getElementById("rows").innerHTML = rows;
    document.getElementById("cols").innerHTML = cols;
    //let geometry = new THREE.BoxGeometry( rows * tileSize, cols * tileSize, tileSize * 0.025 );
    //base.geometry.dispose();
    //base.geometry = geometry;
    // Remove all existing bases
    for( let base of bases ) {
        scene.remove( base );
    }
    bases = [];
    // Remove all existing tiles
    for( let tile of tiles ) {
        scene.remove( tile );
    }
    tiles = [];

    // Generate tiles
    const halfTileSize = tileSize * 0.5;
    const rowOffset = halfTileSize * rows - halfTileSize;
    const colOffset = halfTileSize * cols - halfTileSize;
    for( let row = 0; row < rows; row++ ) {
        for( let col = 0; col < cols; col++ ) {
            // Add base
            const baseGeometry = new THREE.BoxGeometry( tileSize, tileSize, tileSize * 0.025 );
            baseGeometry.computeFaceNormals();
            baseGeometry.computeVertexNormals();
            let base = new THREE.Mesh( baseGeometry, tileMaterial );
            base.position.z = 0;
            base.position.x = row * tileSize - rowOffset;
            base.position.y = col * tileSize - colOffset;
            scene.add( base );
            bases.push( base );
            // Add tile
            /* loader.load( './stl/Field_tile.stl', function ( tileGeometry ) {
                console.log( "Loaded" );
                let tile = new THREE.Mesh( tileGeometry, tileMaterial );
                tile.geometry.scale( 10, 10, 10 );
                tile.position.z = tileSize * 0.025;
                tile.position.x = row * tileSize - rowOffset;
                tile.position.y = col * tileSize - colOffset;
                console.log( tile.geometry );
                
                scene.add( tile );
                tiles.push( tile );
            }); */
            const tileGeometry = new THREE.BoxGeometry( tileSize * 0.95, tileSize * 0.95, tileSize * 0.025 );
            tileGeometry.computeFaceNormals();
            tileGeometry.computeVertexNormals();
            let tile = new THREE.Mesh( tileGeometry, tileMaterial );
            tile.position.z = tileSize * 0.025;
            tile.position.x = row * tileSize - rowOffset;
            tile.position.y = col * tileSize - colOffset;
            scene.add( tile );
            tiles.push( tile );
        }
    }
    // Generate walls
    for( let wall of walls ) {
        scene.remove( wall );
    }
    walls = [];
    const wallZmod = wallHeightMod / 2;
    const wallLateralMod = 0.085;
    if( northWall ) {
        let geometry = new THREE.BoxGeometry( tileSize * rows, tileSize * 0.18, tileSize * wallHeightMod );
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        let material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
        let wall = new THREE.Mesh( geometry, material );
        wall.position.z = tileSize * wallZmod;
        wall.position.y = tileSize * cols * 0.5 - (tileSize * wallLateralMod);
        scene.add( wall );
        walls.push( wall );
    }
    if( southWall ) {
        let geometry = new THREE.BoxGeometry( tileSize * rows, tileSize * 0.18, tileSize * wallHeightMod );
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        let material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
        let wall = new THREE.Mesh( geometry, material );
        wall.position.z = tileSize * wallZmod;
        wall.position.y = 0 - tileSize * cols * 0.5 + (tileSize * wallLateralMod);
        scene.add( wall );
        walls.push( wall );
    }
    if( eastWall ) {
        let geometry = new THREE.BoxGeometry( tileSize * 0.18, tileSize * cols, tileSize * wallHeightMod );
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        let material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
        let wall = new THREE.Mesh( geometry, material );
        wall.position.z = tileSize * wallZmod;
        wall.position.x = tileSize * rows * 0.5 + (tileSize * wallLateralMod);
        scene.add( wall );
        walls.push( wall );
    }
    if( westWall ) {
        let geometry = new THREE.BoxGeometry( tileSize * 0.18, tileSize * cols, tileSize * wallHeightMod );
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        let material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
        let wall = new THREE.Mesh( geometry, material );
        wall.position.z = tileSize * wallZmod;
        wall.position.x = 0 - tileSize * rows * 0.5 + (tileSize * wallLateralMod);
        scene.add( wall );
        walls.push( wall );
    }
    // Move camera based on size of base
    const max = ((rows < cols) ? cols : rows) * 25;
    camera.position.z = max;
    camera.position.y = 0 - max;
}

function setRows() {
    rows = document.getElementById('rows').value;
    updateScreenControls();
}

function setCols() {
    cols = document.getElementById('cols').value;
    updateScreenControls();
}

function updateRows( amount ) {
    if( rows + amount >= 1  &&  rows + amount <= 8 ) {
        rows += amount;
        updateScreenControls();
    }
}

function updateCols( amount ) {
    if( cols + amount >= 1  &&  cols + amount <= 8 ) {
        cols += amount;
        updateScreenControls();
    }
}

function saveSTL() {
    var exporter = new THREE.STLExporter();
    var stlString = exporter.parse( scene );
    var blob = new Blob([stlString], {type: 'text/plain'});
    saveAs( blob, 'tiles-' + rows + 'x' + cols + '.stl' );
}

function reset() {
    document.getElementById("feature")[0].selected = true;
    elems = document.querySelectorAll('select');
    instances = M.FormSelect.init(elems);
    changeFeature();
    updateScreenControls();
}

function changeWallHeight() {
    const i = parseInt(document.getElementById("wallHeight").selectedIndex);
    if( i < 0  ||  i > 1 ) {
        return;
    }
    wallHeightMod = i + wallHeightModBase;
    updateScreenControls();
}

function changeFeature() {
    if( feature !== null ) {
        scene.remove( feature );
        delete feature;
    }
    const features = [ 'none', 'Fountain' ];
    const i = parseInt(document.getElementById("feature").selectedIndex);
    if( i < 1  ||  i > features.length ) {
        return;
    }
    document.getElementById("spinner").style.display = "block";
    loader.load( './stl/' + features[i] + '.stl', function ( geometry ) {
        const material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
        feature = new THREE.Mesh( geometry, material );
        feature.position.z = tileSize * 0.15;
        scene.add( feature );
        document.getElementById("spinner").style.display = "none";
    });
}

updateScreenControls();
animate();

// Enable modals in Materialize
document.addEventListener('DOMContentLoaded', function() {
    var elems = document.querySelectorAll('.modal');
    var instances = M.Modal.init(elems);
});
</script>

<!-- Help Modal -->
<div id="helpModal" class="modal">
    <div class="modal-content">
        <h4>How This Works</h4>
        <p>This app generates tabletop RPG terrain tiles and exports them for 3D printing.</p>
        <p>Use the <em>Rows</em> and <em>Columns</em> sliders to choose the size of the tile.</p>
        <p>Click the <em>Walls</em> buttons to add walls on any 4 sides.</p>
        <p>Click the <em>Download</em> button to download the tile as an STL file.</p>
        <p>This app generates tiles that are 1.25" square and 0.25" walls. This allws a 1", 28mm-scale mini to fit on any square, even if that square contains walls, while also keeping all tiles a consistent size.</p>
    </div>
    <div class="modal-footer">
        <a href="#!" class="modal-close waves-effect waves-green btn-flat">OK</a>
    </div>
</div>

</body>
</html>

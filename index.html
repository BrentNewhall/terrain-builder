<!DOCTYPE html>
<html>
<head>
    <title>Terrain Builder</title>
    <meta name="description" content="Create tabletop terrain tiles and download an STL file for 3D printing." />
    <meta charset="utf-8" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <!-- Compiled and minified Materialize CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <!-- Compiled and minified Materalize JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <link rel="stylesheet" href="style.css" />
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-1706194087486856",
            enable_page_level_ads: true
        });
    </script>
</head>

<body>

<div id="controls">
    <h1>Terrain Builder</h1>
    <ul class="tabs">
        <li class="tab"><a href="#tab-design">Design</a></li>
        <li class="tab"><a href="#tab-customize">Customize</a></li>
        <li class="tab"><a href="#tab-print">Print</a></li>
    </ul>
    <div id="tab-design">
        <div>Rows:</div>
        <input type="range" id="rows" min="1" max="8" value="2" onchange="setRows()" />
        <br />
        <div>Columns:</div>
        <input type="range" id="cols" min="1" max="8" value="2" onchange="setCols()" />
        <br />
        <div>Walls:</div>
        <button class="wallBtnHorizontal" id="northWall" onclick="toggleWall('northWall')">&nbsp;</button><br />
        <button class="wallBtnVertical" id="eastWall" onclick="toggleWall('eastWall')">&nbsp;</button>
        <button class="wallBtnVertical" id="westWall" onclick="toggleWall('westWall')">&nbsp;</button><br />
        <button class="wallBtnHorizontal" id="southWall" onclick="toggleWall('southWall')">&nbsp;</button><br />
    </div>
    <div id="tab-customize">
        Tile style:
        <select id="style" onchange="changeStyle()">
            <option value="0">Simple</option>
            <option value="1">Stone</option>
            <option value="2">Cobblestone</option>
            <option value="-1">(Delete)</option>
        </select>
        <select id="wallHeight" onchange="changeWallHeight()">
            <option value="low">Low walls</option>
            <option value="high">High walls</option>
        </select>
        <br />
        <select id="feature" onchange="changeFeature()">
            <option value="none">Add feature...</option>
            <option value="fountain">Fountain</option>
        </select>
        <!-- Loading spinner -->
        <div id="spinner">
            <div class="preloader-wrapper big active">
                <div class="spinner-layer spinner-blue-only">
                    <div class="circle-clipper left">
                        <div class="circle"></div>
                    </div>
                    <div class="gap-patch">
                        <div class="circle"></div>
                    </div>
                    <div class="circle-clipper right">
                        <div class="circle"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="tab-print">
        <div style="display: flex; justify-content: space-around">
            <button class="btn" id="downloadBtn" onclick="saveSTL()">Download</button>
            <button class="btn orange" onclick="reset()">Reset</button>
            <a class="waves-effect waves-light btn grey modal-trigger" href="#helpModal">Help</a><br />
        </div>
    </div>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- Terrain Builder ad -->
    <ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-1706194087486856"
    data-ad-slot="9003043581"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
    <!-- img width="300" height="250" alt="Temp" src="http://lorempixel.com/300/250" / -->
</div>

<div id="speed"></div>

<script src="three.js"></script>
<script src="STLExporter.js"></script>
<script src="FileSaver.js"></script>
<script src="loaders/STLLoader.js"></script>

<script>
var tileSize = 30.5;
var mesh = null;
var rows = 2;
var cols = 2;
var mouseHovering = false;
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth - 320, window.innerHeight );
document.body.appendChild( renderer.domElement );
renderer.domElement.id = "mainCanvas";
document.getElementById("mainCanvas").addEventListener("mouseover", (e) => {
    mouseHovering = true;
})
document.getElementById("controls").addEventListener("mouseover", (e) => {
    mouseHovering = false;
})

// Base
var origin = new THREE.Vector3( 0, 0, 0 );
/* var baseGeometry = new THREE.BoxGeometry( tileSize, tileSize * 0.1, tileSize );
baseGeometry.computeFaceNormals();
baseGeometry.computeVertexNormals();
let material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
var base = new THREE.Mesh( baseGeometry, material );
scene.add( base ); */
var bases = [];
var tiles = [];

document.getElementById("mainCanvas").addEventListener('click', function(event) {
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    mouse.x = ( event.clientX / document.getElementById("mainCanvas").clientWidth ) * 2 - 1;
    mouse.y = 0 - ( event.clientY / document.getElementById("mainCanvas").clientHeight ) * 2 + 1;
    raycaster.setFromCamera( mouse, camera );
    let intersects = raycaster.intersectObjects( tiles, true );
    if (intersects.length > 0) {
        let selectedObject = intersects[0];
        if( tileType >= 0 ) {
            selectedObject.object.geometry = tileGeometries[tileType];
        }
        /* else if( tileType === 1 ) {
            selectedObject.object.geometry = tileGeometryStone;
        }
        else if( tileType === 2 ) {
            selectedObject.object.geometry = tileGeometryCobble;
        } */
        else if( tileType === -1 ) {
            scene.remove( selectedObject.object );
        }
 	}
    intersects = raycaster.intersectObjects( bases, true );
    if( intersects.length > 0  &&  tileType === -1 ) {
        let selectedObject = intersects[0];
        scene.remove( selectedObject.object );
 	}
}, false)

// Light
var light = new THREE.DirectionalLight( 0xffffff, 1 );
light.position.z = 2;
scene.add( light );

// Position camera
camera.position.z = 70;
camera.position.y = -70;

var clock = new THREE.Clock();
var matrix = new THREE.Matrix4();

// Terrain feature
var feature = null;
var loader = new THREE.STLLoader();

// Setup walls
var walls = [];
var wallFlags = [];
for( let i = 0; i < 4; i++ ) {
    wallFlags[i] = false;
}
var northWall = false;
var southWall = false;
var eastWall = false;
var westWall = false;
var wallHeightModBase = 0.375;
var wallHeightMod = 0.375;

// Tiles
var tileMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff } );
var tileType = 0;
var tileGeometries = [null, null, null];
tileGeometries[0] = new THREE.BoxGeometry( tileSize * 0.95, tileSize * 0.95, tileSize * 0.025 );
tileGeometries[0].scale( 0.95, 0.95, 0.95 );
loader.load( './stl/Field_tile.stl', function ( tileGeometry ) {
    tileGeometries[1] = tileGeometry;
    tileGeometries[1].translate( 0, -2, 0 );
    tileGeometries[1].scale( 0.95, 0.95, 0.95 );
});
loader.load( './stl/Cobblestone.stl', function ( tileGeometry ) {
    tileGeometries[2] = tileGeometry;
    tileGeometries[2].translate( 0, -2, 0 );
    tileGeometries[2].scale( 0.95, 0.95, 0.95 );
});

function toggleWall( wallId ) {
    if( wallId === 'northWall' ) {
        northWall = northWall ? false : true;
        document.getElementById(wallId).style.backgroundColor = (northWall) ? 'black' : 'white';
    }
    else if( wallId === 'southWall' ) {
        southWall = southWall ? false : true;
        document.getElementById(wallId).style.backgroundColor = (southWall) ? 'black' : 'white';
    }
    else if( wallId === 'eastWall' ) {
        eastWall = eastWall ? false : true;
        document.getElementById(wallId).style.backgroundColor = (eastWall) ? 'black' : 'white';
    }
    else if( wallId === 'westWall' ) {
        westWall = westWall ? false : true;
        document.getElementById(wallId).style.backgroundColor = (westWall) ? 'black' : 'white';
    }
    updateScreenControls();
}

function animate() {
    requestAnimationFrame( animate );
    const elapsedTime = clock.getElapsedTime();
    //matrix.makeRotationZ( clock.getDelta() * 2 * Math.PI * 10 );
    //camera.position.applyMatrix4( matrix );
    if( mouseHovering ) {
        camera.position.x = 0;
        camera.position.y = 0;
    }
    else {
        camera.position.x = 75 * Math.cos( elapsedTime * 0.5 );
        camera.position.y = 75 * Math.sin( elapsedTime * 0.5 );
    }
    camera.lookAt( origin );
    renderer.render( scene, camera );
}

function addCustomTile( tileGeometry, row, col, rows, cols, rowOffset, colOffset ) {
    tileGeometry.translate( 0, 0, 0 );
    tileGeometry.computeBoundingBox();
    let tile = new THREE.Mesh( tileGeometry, tileMaterial );
    tile.geometry.scale( 0.95, 0.95, 0.95 );
    tile.position.z = tileSize * 0.025;
    tile.position.x = row * tileSize - rowOffset;
    tile.position.y = col * tileSize - colOffset - 2;
    scene.add( tile );
    tiles.push( tile );
}

function updateScreenControls() {
    document.getElementById("rows").innerHTML = rows;
    document.getElementById("cols").innerHTML = cols;
    //let geometry = new THREE.BoxGeometry( rows * tileSize, cols * tileSize, tileSize * 0.025 );
    //base.geometry.dispose();
    //base.geometry = geometry;
    // Remove all existing bases
    for( let base of bases ) {
        scene.remove( base );
    }
    bases = [];
    // Remove all existing tiles
    for( let tile of tiles ) {
        scene.remove( tile );
    }
    tiles = [];

    // Generate tiles
    const halfTileSize = tileSize * 0.5;
    const rowOffset = halfTileSize * rows - halfTileSize;
    const colOffset = halfTileSize * cols - halfTileSize;
    for( let row = 0; row < rows; row++ ) {
        for( let col = 0; col < cols; col++ ) {
            // Add base
            const baseGeometry = new THREE.BoxGeometry( tileSize, tileSize, tileSize * 0.025 );
            baseGeometry.computeFaceNormals();
            baseGeometry.computeVertexNormals();
            let base = new THREE.Mesh( baseGeometry, tileMaterial );
            base.position.z = 0;
            base.position.x = row * tileSize - rowOffset;
            base.position.y = col * tileSize - colOffset;
            scene.add( base );
            bases.push( base );
            // Add tile
            let tileGeometry = null;
            let tile = null;
            tileGeometry = tileGeometries[0];
            tileGeometry.translate( 0, 0, 0 );
            tileGeometry.computeBoundingBox();
            tile = new THREE.Mesh( tileGeometry, tileMaterial );
            tile.position.z = tileSize * 0.025;
            tile.position.x = row * tileSize - rowOffset;
            tile.position.y = col * tileSize - colOffset;
            scene.add( tile );
            tiles.push( tile );
        }
    }
    // Generate walls
    for( let wall of walls ) {
        scene.remove( wall );
    }
    walls = [];
    const wallZmod = wallHeightMod / 2;
    const wallLateralMod = 0.085;
    if( northWall ) {
        let geometry = new THREE.BoxGeometry( tileSize * rows, tileSize * 0.18, tileSize * wallHeightMod );
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        let material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
        let wall = new THREE.Mesh( geometry, material );
        wall.position.z = tileSize * wallZmod;
        wall.position.y = tileSize * cols * 0.5 - (tileSize * wallLateralMod);
        scene.add( wall );
        walls.push( wall );
    }
    if( southWall ) {
        let geometry = new THREE.BoxGeometry( tileSize * rows, tileSize * 0.18, tileSize * wallHeightMod );
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        let material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
        let wall = new THREE.Mesh( geometry, material );
        wall.position.z = tileSize * wallZmod;
        wall.position.y = 0 - tileSize * cols * 0.5 + (tileSize * wallLateralMod);
        scene.add( wall );
        walls.push( wall );
    }
    if( eastWall ) {
        let geometry = new THREE.BoxGeometry( tileSize * 0.18, tileSize * cols, tileSize * wallHeightMod );
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        let material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
        let wall = new THREE.Mesh( geometry, material );
        wall.position.z = tileSize * wallZmod;
        wall.position.x = tileSize * rows * 0.5 - (tileSize * wallLateralMod);
        scene.add( wall );
        walls.push( wall );
    }
    if( westWall ) {
        let geometry = new THREE.BoxGeometry( tileSize * 0.18, tileSize * cols, tileSize * wallHeightMod );
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        let material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
        let wall = new THREE.Mesh( geometry, material );
        wall.position.z = tileSize * wallZmod;
        wall.position.x = 0 - tileSize * rows * 0.5 + (tileSize * wallLateralMod);
        scene.add( wall );
        walls.push( wall );
    }
    // Move camera based on size of base
    const max = ((rows < cols) ? cols : rows) * 25;
    camera.position.z = max;
    camera.position.y = 0 - max;
}

function setRows() {
    rows = document.getElementById('rows').value;
    updateScreenControls();
}

function setCols() {
    cols = document.getElementById('cols').value;
    updateScreenControls();
}

function updateRows( amount ) {
    if( rows + amount >= 1  &&  rows + amount <= 8 ) {
        rows += amount;
        updateScreenControls();
    }
}

function updateCols( amount ) {
    if( cols + amount >= 1  &&  cols + amount <= 8 ) {
        cols += amount;
        updateScreenControls();
    }
}

function saveSTL() {
    var exporter = new THREE.STLExporter();
    var stlString = exporter.parse( scene );
    var blob = new Blob([stlString], {type: 'text/plain'});
    saveAs( blob, 'tiles-' + rows + 'x' + cols + '.stl' );
}

function reset() {
    document.getElementById("feature")[0].selected = true;
    elems = document.querySelectorAll('select');
    instances = M.FormSelect.init(elems);
    changeFeature();
    updateScreenControls();
}

function changeStyle() {
    const i = parseInt(document.getElementById("style").selectedIndex);
    if( i < 0  ||  i > 3 ) {
        return;
    }
    tileType = i;
    if( tileType === 3 ) {
        tileType = -1;
    }
    //updateScreenControls();
}

function changeWallHeight() {
    const i = parseInt(document.getElementById("wallHeight").selectedIndex);
    if( i < 0  ||  i > 1 ) {
        return;
    }
    wallHeightMod = i + wallHeightModBase;
    updateScreenControls();
}

function changeFeature() {
    if( feature !== null ) {
        scene.remove( feature );
        delete feature;
    }
    const features = [ 'none', 'Fountain' ];
    const i = parseInt(document.getElementById("feature").selectedIndex);
    if( i < 1  ||  i > features.length ) {
        return;
    }
    document.getElementById("spinner").style.display = "block";
    loader.load( './stl/' + features[i] + '.stl', function ( geometry ) {
        const material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
        feature = new THREE.Mesh( geometry, material );
        feature.position.z = tileSize * 0.15;
        scene.add( feature );
        document.getElementById("spinner").style.display = "none";
    });
}

updateScreenControls();
animate();

// Enable modals in Materialize
document.addEventListener('DOMContentLoaded', function() {
    var modalInstances = M.Modal.init(document.querySelectorAll('.modal'));
    var tabInstances = M.Tabs.init(document.querySelectorAll('.tabs'));
    var selectInstances = M.FormSelect.init( document.querySelectorAll('select'));
});
</script>

<!-- Help Modal -->
<div id="helpModal" class="modal">
    <div class="modal-content">
        <h4>How This Works</h4>
        <p>This app generates tabletop RPG terrain tiles and exports them for 3D printing.</p>
        <p>Use the <em>Rows</em> and <em>Columns</em> sliders to choose the size of the tile.</p>
        <p>Click the <em>Walls</em> buttons to add walls on any 4 sides.</p>
        <p>Click the <em>Download</em> button to download the tile as an STL file.</p>
        <p>This app generates tiles that are 1.25" square and 0.25" walls. This allws a 1", 28mm-scale mini to fit on any square, even if that square contains walls, while also keeping all tiles a consistent size.</p>
    </div>
    <div class="modal-footer">
        <a href="#!" class="modal-close waves-effect waves-green btn-flat">OK</a>
    </div>
</div>

</body>
</html>
